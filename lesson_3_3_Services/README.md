# Инициализация сервисов и мониторинг ОС

<img src="./.src/1.jpg" style="width:100%">

## Системы инициализации и особенности использования в разных дистрибутивах

Система инициализации (init system) является одним из первых процессов, который запускается при загрузке операционной системы Linux и отвечает за старт и управление другими процессами. Существуют различные системы инициализации, каждая из которых имеет свои особенности и используется в разных дистрибутивах Linux. Работает как демон и обычно имеет PID 1.

1. SysVinit:
   - SysVinit является одним из старейших методов инициализации в Linux.
   - Основан на скриптах в директории /etc/init.d/ и запускает сервисы последовательно.
   - Отсутствует возможность параллельного запуска сервисов.
   
   1. Инициация и завершение процесса:
      - SysVinit использует скрипты инициализации в директории /etc/init.d/ для запуска и остановки сервисов.
      - Для запуска сервиса используйте команду sudo service название_сервиса start.
      - Для остановки сервиса используйте команду sudo service название_сервиса stop.

   2. Получение списка сервисов:
      - Для получения списка всех доступных сервисов, которые могут быть управляемы через SysVinit, используйте команду `sudo service --status-all`.

   3. Управление запуском сервисов при загрузке:
      - Для добавления сервиса на автозапуск при загрузке системы используйте команду `sudo update-rc.d название_сервиса defaults`.
      - Для удаления сервиса из автозагрузки используйте команду `sudo update-rc.d -f название_сервиса remove`.

   4. Просмотр статуса сервисов:
      - Для просмотра статуса конкретного сервиса используйте команду `sudo service название_сервиса status`.
      - Для более подробной информации о работе сервисов можно использовать команду `ps aux | grep название_сервиса`. 

***
3. Upstart:
   - Upstart был разработан для временного использования в Ubuntu, до перехода на systemd.
   - Имеет фокус на асинхронном запуске сервисов и возможности автоматического рестарта сервисов.
   - Создайте файл конфигурации для вашего сервиса или задачи в директории /etc/init/. Например, myjob.conf.


***
4. OpenRC:
   - OpenRC используется в Gentoo, Alpine Linux, Void Linux и некоторых других дистрибутивах.
   - Поддерживает запуск служб в определенном порядке, подобно SysVinit.
***
2. Systemd:
   - Systemd является современной и наиболее распространенной системой инициализации в современных дистрибутивах Linux.
   - Использует директорию /etc/systemd/system для юнит-файлов, которые описывают поведение служб и других компонентов.
   - Поддерживает параллельный запуск сервисов, управление журналами (journalctl), контроль групп процессов и другие продвинутые функции.

   1. Управление службами:
      - Для запуска службы используйте команду `sudo systemctl start название_службы`
      - Для остановки службы используйте команду `sudo systemctl stop название_службы`
      - Для перезапуска службы используйте команду `sudo systemctl restart название_службы`
      - Для проверки статуса службы используйте команду `sudo systemctl status название_службы`
      - Для включения службы при загрузке системы используйте команду `sudo systemctl enable название_службы`
      - Для отключения службы при загрузке системы используйте команду `sudo systemctl disable название_службы`

   2. Управление юнитами:
      - Systemd управляет службами с помощью конфигурационных файлов, называемых юнитами
      - Конфигурационные файлы для служб находятся в директории /etc/systemd/system/
      - Вы можете создать собственные юниты для ваших служб и настроить их поведение
         - пример: `sudo vim /etc/systemd/system/myservice.service`
            ```bash
            [Unit]
            Description=My Custom Service

            [Service]
            ExecStart=/path/to/your/executable
            Restart=always

            [Install]
            WantedBy=multi-user.target
            ```   
         - обновление systemd: `systemd sudo systemctl daemon-reload`
         - cтарт и активация службы: `sudo systemctl start myservice`
         - автоматический запуск службы при загрузке системы: `sudo systemctl enable myservice`


   3. Журналы системы (journalctl):
      - Systemd хранит журналы системы для отслеживания работы служб и процессов.
      - Для просмотра журналов используйте команду journalctl.
      - Можно использовать различные опции для фильтрации и отображения данных журналов.

         `journalctl` - Просмотр всего журнала

         `journalctl --since "2022-01-01 00:00:00" --until "2022-01-02 00:00:00"` Фильтрация вывода (Например, для просмотра журнала за определенное время)

         `journalctl -f `- продолжающееся отслеживание:

         `journalctl -p err` Фильтрация по уровню журнала (debug, info, notice, warning, err, crit, alert, emerg):
            
         `journalctl _PID=1234` Фильтрация по процессу
            
         `journalctl -u nginx.service` Фильтрация по юниту (службе):

         `journalctl --since "5 minutes ago" -p err` Просмотр ошибок только за последние несколько минут:
       
         `journalctl -t ssh` Поиск ключевых слов:

         `journalctl > journal.log` Экспорт в файл:
     
   4. Системные таймеры:
      - Systemd также управляет системными таймерами для выполнения задач в определенное время.
      - Для создания и управления таймерами используйте команды `systemctl list-timers`, `systemctl start название_таймера`, `systemctl stop название_таймера`.   

      1. Создание таймера:
         - Создайте конфигурационный файл для таймера в директории /etc/systemd/system/. Например, mytimer.timer.
         - В файле укажите время запуска таймера и путь к юниту, который он должен запускать.

      2. Пример конфигурационного файла для таймера (mytimer.timer):
         
         ```bash
         [Unit]
         Description=My Custom Timer

         [Timer]
         OnCalendar=*-*-* 12:00:00
         Unit=mytask.service

         [Install]
         WantedBy=timers.target
         ```

      3. Создание сервиса, который будет запущен таймером (опционально):
         - Создайте конфигурационный файл для сервиса в директории /etc/systemd/system/. Например, mytask.service.
         - Укажите команды или скрипт, который должен быть выполнен при запуске таймера.

      4. Пример конфигурационного файла для сервиса (mytask.service):
         ```bash
         [Unit]
         Description=My Task

         [Service]
         ExecStart=/path/to/your/script

         [Install]
         WantedBy=multi-user.target
         ```

      5. Запуск таймера:
         - После создания файлов таймера и сервиса выполните команду для запуска таймера:
         
         `sudo systemctl start mytimer.timer`

### Команды управления службами

1. Запуск службы:
   
   `sudo systemctl start <service-name>`
   

2. Остановка службы:
   
   `sudo systemctl stop <service-name>`
   

3. Перезапуск службы:
   
   `sudo systemctl restart <service-name>`
   

4. Показать статус службы:
   
   `sudo systemctl status <service-name>`
   

5. Включить запуск службы при загрузке системы:
   
   `sudo systemctl enable <service-name>`
   

6. Отключить запуск службы при загрузке системы:
   
   `sudo systemctl disable <service-name>`
   

Чтобы применить изменения конфигурации службы после внесения правок в ее файлы настройки, необходимо выполнить команду:
`sudo systemctl daemon-reload`

Чтобы применить изменения без перезапуска службы, используйте команду:
`sudo systemctl reload <service-name>`

**Рабочий пример:**
Задача - запускать скрипт для запуска виртуальных машин каждый час

0. Создадим скрипт
   
`vim start_vm.sh`
```bash
#!/bin/bash
# Получаем список всех виртуальных машин
source ./vm_list.txt
# Цикл для включения каждой виртуальной машины
for vm in $VM_LIST; do
    echo "Start VM $vm"
    virsh start $vm
done
```

1. Создание службы systemd:
   - Создайте файл службы в каталоге /etc/systemd/system/, например run_vm.service, с помощью текстового редактора:

```bash
sudo vim /etc/systemd/system/run_vn.service
```

- Вставьте следующий текст, указав путь к вашему скрипту:

```bash
[Unit]
Description=run_vm Service
Wants=network-online.target
After=network-online.target
Wants=run_vm.timer

[Service]
Type=simple
ExecStart=/kvm/scripts/start_vm.sh

[Install]
WantedBy=multi-user.target

```
   - Сохраните и закройте файл.

2. Создайте unit-файл для таймера:
   - Создайте файл с расширением .timer в том же каталоге, например run_vm.timer.
   - Откройте этот файл в текстовом редакторе и добавьте следующий код:

```bash
[Unit]
Description=Timer for running my script every hour
Requires=run_vm.service

[Timer]
OnCalendar=*-*-* *:0:00
Persistent=true
Requires=run_vm.service


[Install]
WantedBy=timers.target
```  

3. Перезагрузите systemd и активируйте таймер:
   - Перезагрузите systemd: `sudo systemctl daemon-reload`.
   - Активируйте созданные unit-файлы: `sudo systemctl enable run_vn.timer` и `sudo systemctl enable run_vn.service`.
   - Запустите таймер: `sudo systemctl start myscript.timer`.


***
## Основные сведения о мониторинге. Команды Ps, Top, Htop
Команда ps - это универсальная утилита для просмотра информации о процессах, запущенных в системе в UNIX-подобных операционных системах, включая Linux. Вот некоторые полезные способы работы с командой ps:

1. Просмотр всех процессов:
   - Для просмотра всех процессов, запущенных в системе, выполните:
     
     `ps aux`
     
   - Эта команда отобразит детальную информацию о каждом процессе, включая PID, пользователь, использование CPU и памяти и многое другое.

2. Просмотр процессов текущего пользователя:
   - Для просмотра процессов, принадлежащих текущему пользователю, используйте:
     
     `ps u`
     

3. Просмотр дерева процессов:
   - Для отображения дерева процессов с их иерархией, выполните:
     
     `ps auxf`
     

4. Поиск процесса по имени:
   - Вы можете использовать команду grep для поиска процесса по его имени или другим характеристикам. Например:
     
     `ps aux | grep <название процесса>`
     

5. Отображение процессов в реальном времени:
   - Для просмотра процессов в реальном времени, используйте команду top или htop.

6. Показать дополнительные поля:
   - Применяя различные ключи, вы можете запросить отображение различных дополнительных полей информации процессов. Например, -l для вывода динамически изменяющегося списка полей.

7. Список всех процессов без управляемых служб:
   - Для просмотра всех процессов, которые не управляются службами systemd, используйте:
     
     `ps -eo 'pid,comm' --sort=-pid`

***
### Команда Kill

Команда kill используется в UNIX-подобных системах (включая Linux) для отправки сигналов процессу или группе процессов. Предпочтительный способ управления службами в Linux - это использовать менеджеры системы инициализации, такие как systemd или SysVinit. Однако, команда kill может быть полезна при необходимости завершить процесс, который не реагирует на стандартные команды управления.


Вот некоторые ключевые аспекты работы с командой kill:

1. Синтаксис команды kill:

   `kill [-сигнал] PID`
   
2. Отправка сигнала процессу:
   - По умолчанию, команда kill отправляет сигнал TERM (15), который просит процесс завершиться. Например:
     
     `kill PID`
     
   - Вы также можете указать номер сигнала напрямую. Например, чтобы отправить сигнал SIGKILL (9) и принудительно завершить процесс, выполните:
     
     `kill -9 PID`
     
3. Просмотр доступных сигналов:
   - Вы можете посмотреть список доступных сигналов, используя команду `kill -l` или `kill -L`

4. Отправка сигнала группе процессов:
   - Если вы хотите отправить сигнал группе процессов, добавьте знак минуса перед номером PID главного процесса. Например:
     
     `kill -9 -PGID`

5. Использование в сочетании с другими утилитами:
   - Команда kill может быть использована в сочетании с другими утилитами, например, для автоматизации процесса завершения нескольких процессов.

Помните, что использование сигнала SIGKILL может быть агрессивным и привести к потере данных. Рекомендуется сначала попробовать отправить сигнал SIGTERM (15), который дает процессу возможность корректно завершить работу, прежде чем его принудительно завершить с помощью SIGKILL (9).

***
## Pipes.Переадресация и потоки ввода-вывода

### Pipes
Pipes - это механизм в UNIX-подобных операционных системах, который позволяет объединять несколько команд в цепочку, так чтобы вывод одной команды стал вводом для другой. При использовании пайпов символ | используется для передачи данных между процессами.

`ls -l | grep ".txt"`  отображения только определенных файлов

Здесь команда ls -l выводит список файлов и каталогов в длинной форме, а затем через пайп вывод передается команде grep ".txt", которая фильтрует вывод и отображает только строки, содержащие .txt.

**Полезные Pipes:**

`cat file.txt | wc -l` подсчет числа строк в файле

`cat data.txt | sort | uniq -c | sort -nr | head -1`  поиск наиболее часто встречающегося значения в файле

`cat text.txt | wc -w`  подсчет числа слов в файле

`cat text.txt | sort -u` сортирует и фильтрует только уникальные строки

### Переадресация и потоки ввода-вывода
В Linux существует механизм переадресации и потоков ввода-вывода, который позволяет управлять потоками данных между процессами, файлами и устройствами. Это очень мощный и часто используемый инструмент в командной строке Linux. 

1. Перенаправление вывода (>):
   - Символ > используется для перенаправления вывода команды в файл. Например:
     
     `ls -l > files.txt`
     

2. Добавление вывода в конец файла (>>):
   - Символ >> используется для добавления вывода в конец файла, не затирая уже существующие данные. Например:
     
     `echo "новая строка" >> file.txt`
     

3. Перенаправление стандартного ввода (<):
   - Символ < используется для чтения данных из файла и передачи их в стандартный ввод команды. Например:
     
     `sort < file_to_sort.txt`
     

4. Подключение потоков данных (|):
   - Символ | (pipe) используется для связывания вывода одной команды с вводом другой команды. Например:
     
     `cat file.txt | grep "pattern"`
     

5. Перенаправление стандартного вывода и ошибок:
   - Символ 2> используется для перенаправления стандартного потока ошибок. Например:
     
     `ls non_existent_file 2> error.log`
     

6. Перенаправление вывода и ошибок в один файл:
   - Символ &> используется для перенаправления как стандартного вывода, так и потока ошибок в один и тот же файл. Например:
     
     `ls non_existent_file &> output_and_error.log`
     
**Пример**

Допустим, у вас есть файл list.txt с перечнем файлов и каталогов. Чтобы записать список файлов и каталогов в этот файл, используйте команду ls с перенаправлением вывода (>):

`ls > list.txt`
     
***
## Linux Bash и сценарии командной оболочки

Bash (Bourne Again Shell) - это командная оболочка Unix и Linux, которая предоставляет пользователю интерфейс для взаимодействия с операционной системой через командную строку. Bash является одной из наиболее популярных оболочек командной строки в Unix-подобных операционных системах благодаря своей мощности, гибкости и множеству встроенных функций и возможностей.

Например, создадим скрипт, который создаст директорию и в ней файл
```bash
echo "Привет, мир!"
echo "Текущий каталог: $(pwd)"
echo "Список файлов:"
ls
```
`vim script.sh`
в первой строке должен содержаться путь к интерпретатору
```bash
#!/bin/bash

echo "Привет, мир!"
echo "Текущий каталог: $(pwd)"
echo "Список файлов:"
ls
```
`chmod +x script.sh` дадим права на исполнение
`bash script.sh` запускать в терминале Linux с помощью интерпретатора
`./script.sh` запуск скрипта
feef




***
## Python для системного администратора

Логика в программировании, включая Python, относится к способу организации и структурирования кода для выполнения определенных задач. Основные концепции логики в Python включают в себя использование условных операторов, циклов, операторов сравнения и логических операторов.

1. Условные операторы (if-else):
   Условные операторы if, elif и else используются для выполнения различных действий в зависимости от выполнения определенного условия. Пример:
   
```python
   x = 10
   if x > 0:
       print("Число положительное")
   elif x < 0:
       print("Число отрицательное")
   else:
       print("Число равно нулю")
```   

2. Циклы (for, while):
   Циклы используются для многократного выполнения блока кода. Цикл for используется для перебора элементов в итерируемом объекте, а цикл while выполняет блок кода до тех пор, пока заданное условие истинно. Пример цикла for:
   
```python
   for i in range(5):
       print(i)
```   

3. Операторы сравнения:
   Операторы сравнения используются для сравнения значений. Некоторые из них:
```
   ==: равно
   !=: не равно
   >: больше
   <: меньше
   >=: больше или равно
   <=: меньше или равно

```
4. Логические операторы:
   Логические операторы позволяют комбинировать условия. Некоторые из них:
```
   - and: логическое "и"
   - or: логическое "или"
   - not: логическое "не"

```
5. Встроенные функции all() и any():
```
   - all(): возвращает True, если все элементы истинны
   - any(): возвращает True, если хотя бы один элемент истинен

```

***
Полезные примеры
**Проверка доступности хоста**
```python
import ping3

def check_host(ip_address):
    response = ping3.ping(ip_address)
    if response is not None:
        return True
    else:
        return False

if __name__ == "__main__":
    ip_address = input("Введите IP адрес для проверки доступности: ")
    if check_host(ip_address):
print(f"Хост доступен")
    else:
print(f"Хост недоступен")

```
**Резервное копирование системы Debian на удаленный хост с использованием Python**
```python
import subprocess

def backup_system():
    # Создание архива системы
    backup_command = "tar czf /tmp/system_backup.tar.gz /"
    subprocess.run(backup_command, shell=True)

    # Копирование архива на удаленный хост
    remote_host = "user@remote_host:/path/to/backup/"
    copy_command = f"scp /tmp/system_backup.tar.gz {remote_host}"
    subprocess.run(copy_command, shell=True)

if __name__ == "__main__":
    backup_system()
    print("Резервное копирование системы Debian завершено и передано на удаленный хост.")

```



***
## Домашнее задание

1. Создайте 3 файла с помошью команды
```
echo "apple
banana
apple
grape" > data1.txt

echo "banana
orange
grape
kiwi" > data2.txt

echo "melon
apple
grape
orange" > data3.txt
```

Напишите комбинацию команд с использованием Pipes, которая выполнит следующие действия:
   - Извлечет только уникальные строки из файлов data1.txt, data2.txt и data3.txt
   - Отсортирует уникальные строки по алфавиту
   - Подсчитает количество строк
   - Запишет результат выполнения комбинации команд в файл output.txt
   (отчет - скрипт)

1. Создайте bash-скрипт с именем install_utilites.sh, который будет:
   
   - устанавливать пакет nmap для сканирования сети
   - сканировать сеть на наличие хостов и сохранять вывод в файл found_hosts.txt
   (отчет - скрипт)

2. Создать bash-скрипт с именем check_disk_space.sh, который будет:

   - Определять общий объем свободного и используемого дискового пространства на системе.
   - Сохранять вывод в файл disk_space.txt
   (отчет - скрипт)

**дополнительно**

3. Создайте юнит-файл для сервиса в Systemd, который будет автоматически запускаться при загрузке системы. Данный юнит файл должен запускать скрипт backup.sh для создания резервной копии домашней директории /home/root в директории /home/backup.
(отчет - содержимое юнит файла, скрипт, вывод systemctl status для юнит файла)


***
**Для отчета:**
- Cоздать в личном репозитории организаци github ветку lesson_3_3
- Cоздать директорию lesson_3_3 и разместить отчет о проделанной работе
- Cделать push и pull request на сайте, в качестве рецензента добавить пользователя AndreyChuyan