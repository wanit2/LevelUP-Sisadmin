# Скрипты, файлы логов, работа с файловыми редакторами

<img src="./.src/1.jpg" style="width:100%">

## Планировщик задач CronTab и At

CronTab и At - это системные инструменты в Unix-подобных операционных системах, таких как Linux, которые позволяют запускать задачи по расписанию.

**CronTab** является стандартным инструментом для планирования периодических задач в Unix-системах. С его помощью можно создавать Cron-задачи, которые выполняются на определенное время, день недели или месяца. CronTab использует файлы конфигурации Cron, такие как /etc/crontab и файлы в директории /etc/cron.d/, чтобы определить расписание задач. Пользователи также могут создавать свои собственные Cron-задачи с помощью команды crontab -e. Пример задачи Cron:

<img src="./.src/2.jpg" style="width:100%">

_Запуск скрипта каждую минуту_
```
* * * * * /путь/к/скрипту.sh
```
примеры временных промежутков
```
1. Минуты (0-59):
   - * - каждая минута
   - */5 - каждые 5 минут
   - 0,15,30,45 - в определенные минуты 0, 15, 30 и 45
   - 20-40 - каждая минута с 20 по 40

2. Часы (0-23):
   - * - каждый час
   - */2 - каждые 2 часа
   - 0,6,12,18 - в определенные часы 0, 6, 12 и 18
   - 9-17 - каждый час с 9 до 17

3. Дни месяца (1-31):
   - * - каждый день
   - */3 - каждый третий день
   - 1,15 - 1 и 15 число каждого месяца

4. Месяцы (1-12):
   - * - каждый месяц
   - */4 - каждый четвертый месяц
   - 2,6 - Февраль и Июнь

5. Дни недели (0-6, где 0=воскресенье):
   - * - каждый день недели
   - */2 - каждый второй день недели
   - 1,5 - Понедельник и Пятница
```

***
**At** - это инструмент, который позволяет запускать одноразовые задачи на определенное время. Задачи, созданные с помощью At, выполняются только один раз и затем удаляются из очереди. Пользователи могут устанавливать время запуска задачи с помощью команды at, указывая время и дату в формате, который поддерживает At. Пример задачи At:

_Запуск скрипта в 14:30_
```
at 14:30
> /путь/к/скрипту.sh
> Ctrl+D
```

## Основы написания скриптов и скрипты резервного копирования
1. Последовательность выполнения:
   - Команды в bash скрипте выполняются последовательно сверху вниз, если не указано иное.

2. Условия:
   - Условные операторы, такие как if, elif, else, позволяют выполнять блоки команд в зависимости от условий.
```bash
   #!/bin/bash

   # проверка наличия файла и определение его типа
   file="/etc/passwd"

   if [ -f "$file" ]; then
      echo "$file существует."
   elif [ -d "$file" ]; then
      echo "$file существует, но является директорией."
   else
      echo "$file не существует."
   fi
```
3. Циклы:
   - Циклы, такие как for, while, могут использоваться для выполнения повторяющихся операций.
```bash
   #!/bin/bash

   # перебираем элементы в массиве и выводим их в консоль
   # Объявляем массив
   fruits=("яблоко" "апельсин" "банан" "груша")

   # Цикл for для перебора элементов массива
   for fruit in "${fruits[@]}"
   do
      echo "Фрукт: $fruit"
   done
```
4. Функции:
   - Функции позволяют организовать повторно используемый код и улучшить читаемость и структуру скрипта.
```bash
#!/bin/bash

# Определение функции, возвращающей значение
function add_numbers {
   result=$(($1 + $2))
   result2=$(($1 - $2))
   # Возвращение результата
}

# Вызов функции и сохранение возвращенного значения
add_numbers 3 5
echo "Разница равна: $result2"

add_numbers 10 -5
echo "Сумма равна: $result"
```
;;

5. Переменные:
   - Переменные используются для хранения данных и передачи значений между командами.
```bash
   #!/bin/bash

   # Объявляем переменную
   name="Иван"
   age=30

   # Выводим значения переменных на экран
   echo "Привет, меня зовут $name и мне $age лет."

```
6. Ввод/вывод:
   - Использование команд для ввода данных (через параметры, потоки ввода) и вывода результатов (на экран, в файлы).
```bash
   #!/bin/bash

   # Чтение данных через параметры
   name=$1
   age=$2

   # Вывод вводимых данных на экран
   echo "Привет, меня зовут $name и мне $age лет."

   # Чтение данных через поток ввода
   echo "Введите свой любимый цвет:"
   read color

   # Вывод результатов на экран
   echo "Ваш любимый цвет: $color"

   # Запись результатов в файл
   echo "Имя: $name, Возраст: $age, Цвет: $color" > output.txt
   echo "Результаты записаны в файл output.txt"
```

7. Переадресация и потоки:
   - Переадресация позволяет изменять направление потоков ввода и вывода для команд.
```bash
   #!/bin/bash

   # Создаем простой текстовый файл
   echo "Пример текста для файла" > example.txt

   # Перенаправляем стандартный вывод в текстовый файл
   cat example.txt > output.txt

   # Читаем содержимое файла и передаем его в другую команду для обработки
   cat example.txt | grep "текст"

   # Перезаписываем (>) стандартный вывод команды в файл
   ls -l > file_list.txt

   # Добавляем (>>) стандартный вывод команды в конец файла
   date >> file_list.txt

   # Перенаправляем стандартный вывод и ошибки в разные файлы
   ls -l example.txt non_existent_file.txt > output.txt 2> errors.txt

   # Перенаправляем стандартный вывод и ошибки в один файл
   ls -l example.txt non_existent_file.txt > combined_output.txt 2>&1
```

8. Обработка ошибок:
   - Обработка ошибок с использованием операторов trap, exit, return и других механизмов.

```bash
   #!/bin/bash

   # Функция для обработки ошибок
   error_handler() {
      exit_code=$?
      echo "Произошла ошибка! Код ошибки: $exit_code"
      exit $exit_code
   }

   # Устанавливаем trap для вызова функции error_handler при ошибке
   trap 'error_handler' ERR

   # Симуляция ошибочной команды (деление на ноль)
   result=$((10/0))

   # Проверяем код завершения и возвращаем ошибку при необходимости
   if [ "$?" -ne 0 ]; then
      echo "Ошибка: Деление на ноль"
      exit 1
   fi

   echo "Пример успешного выполнения скрипта"

   # Возвращаем код в зависимости от успешности скрипта
   if [ "$?" -eq 0 ]; then
      return 0
   else
      return 1
   fi
```

***
**Пример логической структуры bash скрипта:**

```bash
#!/bin/bash

# Определение переменной
name="John"

# Проверка условия
if [ "$name" == "John" ]; then
    echo "Hello, John!"
else
    echo "Hello, stranger!"
fi

# Цикл для вывода чисел от 1 до 5
for i in 1 2 3 4 5
do
    echo "Number: $i"
done
```


### Полезные bash-скрипты
1. Скрипт для резервного копирования файлов:
   - Этот скрипт создаст резервную копию указанных файлов или каталогов и сохранит их в отдельной папке с текущей датой:
   
```bash
#!/bin/bash

backup_dir="/путь/к/папке_с_резервными_копиями/$(date +%F)"
source_dir="/путь/к/искомым_файлам_или_директориям"

mkdir -p $backup_dir
cp -r $source_dir $backup_dir
```

2. Скрипт для мониторинга использования дискового пространства:
   - Этот скрипт проверит использование диска и отправит уведомление, если свободное место на диске станет меньше указанного порога:

```bash
#!/bin/bash

threshold=90
current_usage=$(df -h | grep "/dev/sda1" | awk '{print $5}' | tr -d '%')

if [ $current_usage -ge $threshold ]; then
    echo "WARNING: Disk usage is above 90%."
fi
```

### Полезная практика: 


1. Добавление Шебанга: Всегда добавляйте шебанг (shebang) #!/bin/bash в начало скрипта, чтобы указать, что скрипт должен выполняться в интерпретаторе bash.

2. Используйте комментарии: Добавляйте понятные комментарии к коду, чтобы описать его назначение, особенности и решаемую задачу.

3. Обработка ошибок: Включайте проверки ошибок и обработку исключений в ваш скрипт, чтобы обеспечить надежную и безопасную работу.

4. Используйте переменные: Используйте переменные для хранения значений, которые могут повторно использоваться в разных частях скрипта.

5. Правильное форматирование: Оформляйте скрипт правильно, используя отступы, переносы строки и пустые строки для улучшения читаемости кода.

6. Проверка наличия необходимых утилит: Проверяйте наличие необходимых утилит или программ в системе перед их использованием в скрипте.

7. Используйте условия и циклы: Используйте условия (if, else, elif) и циклы (for, while) для реализации логики выполнения скрипта.

8. Разбивайте код на функции: Разбивайте код на функции для лучшей организации и управления кодом.

9. Тестирование: Тестируйте ваш скрипт на разных сценариях использования и системах, чтобы убедиться в его корректной работы.



## Примеры скриптов автоматизации рутинных действий

### 1. Резервное копирование файлов
```bash
#!/bin/bash

# Папка для резервного копирования
source_dir="/путь_к_папке"
# Папка для сохранения резервной копии
backup_dir="/путь_к_папке_с_резервными_копиями"
# Создание каталога для резервной копии, если он не существует
mkdir -p $backup_dir
# Создание имени файла для резервной копии с текущей датой
backup_file="$backup_dir/backup_$(date +'%Y-%m-%d').tar.gz"
# Создание резервной копии
tar -czf $backup_file $source_dir

echo "Резервное копирование завершено: $backup_file"
```


### 2. Генерация отчета об использовании дискового пространства
```bash
#!/bin/bash

# Генерация отчета и запись в файл
df -h > disk_usage_report.txt

echo "Создан отчет об использовании дискового пространства: disk_usage_report.txt"
```


### 3. Автоматизация установки пакетов
```bash
#!/bin/bash

# Список пакетов для установки
packages="package1 package2 package3"
# Обновление списка пакетов
sudo apt update
# Установка пакетов
sudo apt install $packages
```

### 4. Архивация и удаление старых лог-файлов
```bash
#!/bin/bash

# Папка с лог-файлами
log_dir="/var/log"
# Период, после которого логи будут архивированы и удалены (например, 30 дней)
days_to_keep=2
# Архивирование и удаление логов
find $log_dir -type f -mtime +$days_to_keep -exec tar -czf /root/1.tar.gz {} +
# res=$(find $log_dir -type f -mtime +$days_to_keep)
echo "Нашлось ($res)"
```
### 5. Добавление записей в файл host
```bash
#!/bin/bash

# IP адрес и доменное имя для добавления в файл hosts
ip_address="127.0.0.1"
domain_name="example.com"

# Проверка наличия записи в файле hosts
if grep -q "$domain_name" /etc/hosts; then
    echo "Запись для $domain_name уже существует в файле hosts"
else
    # Добавление новой записи в файл hosts
    echo "$ip_address $domain_name" | sudo tee -a /etc/hosts >/dev/null
    echo "Запись для $domain_name успешно добавлена в файл hosts"
fi
```

**grep** - это мощная командная утилита в Unix и Linux, которая используется для поиска текста в файлах или выводе других команд. Вот некоторые основные способы использования команды grep:

1. Простой поиск: Для поиска строки в файле, используйте следующий синтаксис:
   
   `grep "pattern" filename`
   Например, чтобы найти строку "hello" в файле file.txt, выполните:
   > grep "hello" file.txt
   

2. Игнорирование регистра: Для игнорирования регистра при поиске, используйте опцию -i:
   > grep -i "hello" file.txt

3. Поиск в рекурсивных каталогах: Для поиска во всех файлах в указанном каталоге и его подкаталогах, используйте опцию -r:
   > grep -r "pattern" directory

4. Отображение номеров строк: Для отображения номеров строк вместе с результатами поиска, используйте опцию -n:
   > grep -n "pattern" file.txt

5. Исключение строк: Для поиска строк, не содержащих указанный шаблон, используйте опцию -v:
   > grep -v "pattern" file.txt

6. Регулярные выражения: grep поддерживает регулярные выражения для более гибкого поиска. Например, для поиска строк, начинающихся с "abc", используйте:
   > grep "^abc" file.txt

7. Использование команд: grep может быть использован для фильтрации вывода других команд. Например:
   > ps aux | grep "process_name"

**tee** в UNIX и UNIX-подобных системах используется для чтения из стандартного ввода, записи в стандартный вывод и одновременного записи в один или несколько файлов

1. Простая запись в файл: 
   > command | tee filename
   Это позволяет записывать вывод команды command в файл filename.

2. Дополнительный аргумент -a для добавления в файл:
   > command | tee -a filename
   Это добавит результат вывода в конец файла filename вместо перезаписи.

3. Запись в несколько файлов:
   > command | tee file1 file2 file3
   Это записывает вывод команды command во все указанные файлы file1, file2, file3.

4. Создание файлов и запись: 
   > echo "Hello, World" | tee file1 file2 file3
   Это создаст три файла (file1, file2, file3) с текстом "Hello, World".

5. Совместное использование с sudo для записи в системные файлы:
   > echo "127.0.0.1 localhost" | sudo tee -a /etc/hosts
   Это добавит запись в файл /etc/hosts с правами суперпользователя.

6. Если вы хотите вставить блок текста в скрипт на Bash, вам нужно использовать оператор перенаправления <<EOF. 

   ```bash
cat <<EOF >> test.txt
1
12
123
1234
EOF
   ```


## Полезные инструменты для работы с Linux-серверами

1. atop: Продвинутый мониторинг ресурсов системы, позволяющий просматривать информацию об использовании ЦП, памяти, диска и сети в реальном времени.

2. tmux: Терминальный мультиплексор, который позволяет запускать несколько отдельных терминалов в одном окне и управлять ими.

   1. Основные команды в tmux:
      - Ctrl+b — основная комбинация клавиш, которая перед предшествует командам в tmux.
      - Ctrl+b, c — создание нового окна.
      - Ctrl+b, % — разделение текущего окна по вертикали.
      - Ctrl+b, " — разделение текущего окна по горизонтали.
      - Ctrl+b, стрелки — навигация между разделенными окнами.
      - Ctrl+b, d — выход из сессии tmux, но оставить ее активной.

   2. Управление окнами в tmux:
      - Ctrl+b, номер_окна — переключение на указанное окно.
      - Ctrl+b, w — отображение списка окон для выбора.
      - Ctrl+b, & — закрытие текущего окна.
      - Ctrl+b, $ — переименование текущего окна.

   3. Управление панелями в tmux:
      - Ctrl+b, % — создание вертикальной панели.
      - Ctrl+b, " — создание горизонтальной панели.
      - Ctrl+b, стрелки - навигация между панелями.
      - Ctrl+b, x — закрытие текущей панели.

   4. Выход из tmux:
      - Для выхода из tmux, введите exit во всех терминальных окнах внутри tmux, либо нажмите Ctrl+b, d, чтобы выйти из текущей сессии tmux, оставляя ее в фоновом режиме.

3. ncdu: Простая консольная программа для анализа использования дискового пространства и нахождения крупных файлов и папок.
   
   Навигация в интерфейсе ncdu:
      - Используйте стрелки и клавиши Enter для навигации по файловой системе.
      - d — углубление в директорию.
      - u — возврат на уровень выше.
      - q — выход из ncdu.

4. iftop: Консольный сетевой монитор, который отображает текущий трафик с детализацией по исходящему и входящему трафику.

   Отображение информации в iftop:
      - В верхней части экрана отображается общая статистика по сетевому трафику.
      - В нижней части экрана отображается список активных соединений с информацией о сетевом адресе, пропускной способности и т.д.

   Навигация и управление в iftop:
      - p — переключение между отображением всех подключений и подключений к определенному хосту.
      - n — сортировка списка соединений по пропускной способности.
      - s — изменение интервала обновления информации о трафике.
      - q — выход из iftop.

5. sysstat: Пакет утилит для мониторинга и анализа производительности системы, включая sar, mpstat, iostat.

   Настройка сбора статистики:
      
      - По умолчанию sysstat собирает статистику каждые 10 минут. Вы можете настроить интервал сбора и сохранения данных в файле /etc/sysstat/sysstat. В этом файле вы можете изменить период сбора данных, количество сохраняемых данных и другие параметры.

   Использование утилит в sysstat:
      - sar — анализ системной активности (ЦП, память, диски, сеть) на основе данных, собранных в определенный период.
      - iostat — отображение статистики использования дисковой подсистемы.
      - mpstat — отображение статистики по каждому ядру процессора.
      - pidstat — отображение статистики по процессам.

## Работа с логами. Утилиты Tail, Multitail

**tail** — это простая утилита в Unix-подобных системах для чтения последних строк из файла.
   Пример использования:
   > tail -f /var/log/syslog

либо

   > journalctl -f

   Эта команда позволит вам просматривать обновления в лог файле /var/log/syslog в реальном времени. Флаг -f означает "фоллов" (следить за обновлениями).

**multitail** — это более расширенная версия tail, позволяющая отслеживать несколько лог файлов одновременно.
   Пример использования: 
   > multitail /var/log/syslog /var/log/messages

   Эта команда позволит вам отслеживать сразу два лог файла в реальном времени. Вы можете добавить сколько угодно файлов для мониторинга

   Навигация и управление:

      - В tail и multitail вы можете использовать клавиши управления для навигации по лог файлам:
      - Ctrl + C для остановки чтения лога.
      - Ctrl + F для прокрутки вниз.
      - Ctrl + B для прокрутки вверх.
      - q для выхода из утилиты.

   Фильтрация и поиск:

      - В multitail вы можете фильтровать содержимое лог файлов, используя регулярные выражения.
      - Пример: multitail -l "error" /var/log/syslog. Эта команда покажет только строки с ключевым словом "error" в лог файле /var/log/syslog.

## Редакторы sed и awk

**sed** и **awk** — это два мощных инструмента для обработки и манипулирования текстовой информацией в Unix-подобных системах. Оба инструмента предоставляют различные команды и возможности для работы с текстом. Вот краткое описание того, как использовать sed и awk:

**sed (Stream Editor)**:
- sed — это инструмент для обработки текста из стандартного ввода или файла и вывода результата на стандартный вывод.
- Пример использования: sed 's/old_text/new_text/g' file.txt. Это заменит все вхождения old_text на new_text в файле file.txt.
- sed может выполнять различные операции над текстом, такие как поиск и замена, удаление строк, вставка текста и т.д.

   Синтаксис команды sed:
   `sed [опции] 'команда' файл`


   _Примеры использования sed:_

  1. Замена текста:
     - Заменить все вхождения слова "foo" на слово "bar" в файле file.txt и вывести результат на стандартный вывод:
       
       `sed 's/foo/bar/g' file.txt`
       

  2. Удаление строк:
     - Удалить все строки, которые содержат слово "error" из файла file.txt:
       
       `sed '/error/d' file.txt`
       

  3. Добавление текста:
     - Добавить строку "New line" после каждой строки в файле file.txt и вывести результат на стандартный вывод:
       
       `sed 's/$/ New line/' file.txt`
       

  4. Использование регулярных выражений:
     - Использовать регулярное выражение для поиска и замены текста в файле file.txt:
       
       `sed 's/[0-9]\{3\}/NUMBER/g' file.txt`
       

  5. Сохранение изменений в файле:
     - Сохранить изменения в исходном файле file.txt:
       
       `sed -i 's/foo/bar/g' file.txt`
       

  6. Команды многострочного редактирования:
     - Выполнить несколько команд с помощью многострочного редактирования:
       
         ```bash
         sed '
         s/foo/bar/g
         s/123/456/g
         ' file.txt
         ```
       

  7. Применение нескольких команд:
     - Применить несколько команд к файлу file.txt:
       
       `sed -e 's/foo/bar/g' -e 's/123/456/g' file.txt`
       



awk:
- awk — это универсальный язык программирования и утилита для обработки и анализа данных в текстовом формате.
- Пример использования: awk '{print $1}' file.txt. Это напечатает первую колонку каждой строки в файле file.txt.
- awk также может выполнять различные операции, такие как фильтрация строк на основе условий, обработка и агрегация данных, работа с массивами и т.д.

   _Примеры использования awk:_

  1. Простейшая команда awk:
     
     `awk '{print $1}' file.txt`
     
     Эта команда выведет первое поле из каждой строки файла file.txt.

  2. Условия в awk:
     
     `awk '{if($1 > 10) print $0}' file.txt`
     
     Это покажет строки, где первое поле больше 10.

  3. Управление полями:
     
     `awk -F, '{print $1, $2}' file.csv`
     
     В этом случае awk используется для обработки данных CSV-файла с разделителем запятая.

  4. Встроенные переменные awk:
     - $0 - содержит всю строку
     - $1, $2, ..., $n - содержат соответствующие поле строки
     - NF - число полей в строке
     - NR - номер текущей строки

  5. Сложные выражения:
     
     `awk '{print $1 + $2}' file.txt`
     
     Это печатает сумму первых двух полей в каждой строке файла.

  6. Сложные шаблоны:
     
     `awk '/pattern/ {print $0}' file.txt`
     
     Это выводит строки, содержащие указанный шаблон.

  7. Скрипты awk:
     Вы также можете написать скрипты awk в отдельных файлах и вызывать их следующим образом:
     
     `awk -f script.awk file.txt`
     


***
## Домашнее задание

2. Напишите скрипт для регулярного мониторинга использования дискового пространства и отправки уведомлений об истощении места.

3. Напишите скрипт с командой awk, которая выводит сообщения о неудачных входах в систему

4. Напишите срипт на sed для разрешения ssh авторизации для суперпользователя (замены в конфигурационном файле строки с RootAutorisation no на RootAutorisation yes)

**дополнительно**

5. Написать скрипт, который будет по расписанию мониторить лог-файл на предмет определенного ключевого слова и записывать найденные строки в отдельный файл.

   Требования к скрипту:
   - Скрипт должен по использовать утилиты cron, tee, tail и sed.
   - Скрипт должен запускаться автоматически с помощью cron каждые 5 минут.
   - Скрипт должен мониторить вывод журналов journalctl
   - Если в лог-файле найдено ключевое слово "ERROR", скрипт должен записать строку с ошибкой в отдельный файл errors.log.
   - Структура и содержание файла errors.log должно дополнятся при каждом новом запуске скрипта.
   - Скрипт должен удалять устаревшие записи, оставляя только последние 100 строк
   


***
**Для отчета:**
- Cоздать в личном репозитории организаци github ветку lesson_3_4
- Cоздать директорию lesson_3_4 и разместить отчет о проделанной работе
- Cделать push и pull request на сайте, в качестве рецензента добавить пользователя AndreyChuyan